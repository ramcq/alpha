#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Animating Algorithms: Project Progress Report
\layout Author

Steven Cooper (
\family typewriter 
sjc209
\family default 
), Graham Le Page (
\family typewriter 
gpl26
\family default 
),
\newline 
Zhan Li (
\family typewriter 
zrll2
\family default 
), Robert McQueen (
\family typewriter 
ram48
\family default 
),
\newline 
Andrew Medworth (
\family typewriter 
am502
\family default 
), Neofytos Mylona (
\family typewriter 
nm314
\family default 
),
\newline 
Sidath Senanayake (
\family typewriter 
sas58
\family default 
), Alan Treanor (
\family typewriter 
ajit2
\family default 
)
\layout Standard

{
\layout Standard

4.2 Module implementation and testing
\newline 

\layout Standard

The next task is to write the code of the classes and to test them in isolation.
 This is likely to require the construction of special test harnesses for
 separate classes.
 The deliverables for this task are a progress report by the team manager,
 which must be delivered in writing, plus code of the implementations and
 a description of the testing procedures and their results, which may be
 online.
\newline 

\layout Standard

Changes in specification or design (if any)
\layout Standard

Difficulties (if any)
\layout Standard

Project log:
\layout Itemize

Interfaces and modules
\layout Itemize

Authorship
\layout Itemize

Status (written, tested, work in hand...)
\layout Itemize

Copies of test results
\layout Itemize

Pointers to on-line sources 
\newline 

\newline 

\newline 
Animator API - Rob, Steven, Sid, Andrew
\layout Itemize

Shell appearance - Neofytos, Graham
\layout Itemize

Algorithm API & friends - Rob
\layout Itemize

Phase 2
\layout Itemize

Test Animators } Graph test - Richard
\layout Itemize

Test Algorithms} Vector test - Alan
\layout Itemize

Queue - Rob
\layout Itemize

GraphAnimator - Steven
\layout Itemize

VectorAnimator - Andrew
\layout Itemize

Document API - All coders
\layout Itemize

Document user interface - Neofytos, Graham
\layout Standard

}
\layout Section

Introduction
\layout Standard

This is the progress report document for the 
\begin_inset Quotes eld
\end_inset 

Animating Algorithms" (Topic 8.5) Computer Science Tripos Part IB / Part
 II (General) group project.The authors are the members of group 
\begin_inset Quotes eld
\end_inset 

Alpha", listed individually above.
 This project is being overseen by Steven Hand (
\family typewriter 
\series bold 
smh22@cam.ac.uk
\family default 
\series default 
).
\layout Section

Changes from specification
\layout Subsection

Algorithm Package
\layout Standard

* Provision of initial data and animator moved to constructors instead.
\layout Subsection

Animator Package
\layout Subsection

Vector Animator
\layout Itemize

Markers and Pointers merged into Arrows.
\layout Itemize

Copy element from one pointer to another method changed to take offsets
 rather than pointers.
\layout Itemize

Specific compare two elements method removed vector primitives; un-necessary
 since you can just use highlight pointer.
\layout Itemize

Delete element method removed; vector lengths are invariant for sorting
 algorithms (moved to project extensions list).
\layout Itemize

Split vector method also removed, for similar reason (preserve invariant
 length).
\layout Itemize

Boolean highlight supplemented with a few seconds of flashing (for both
 arrows and vector elements).
\layout Standard

Include difficulties - refer to specification
\layout Section

Code status
\layout Standard

(Written/tested/to do etc) Include authors
\layout Subsection

Algorithms (Sid)
\layout Standard

Four out of the five have been written, the fifth is in progress.
 None have yet been tested.
\layout Subsection

Animators
\layout Subsubsection

Graph animators (Steven)
\layout Standard

Almost complete, only highlighting nodes and edges and algorithm step messages
 have to be completed.
 The messages will be completed when the shell has been finished.
 Untested.
\layout Subsubsection

Vector animators (Andrew)
\layout Standard

The vast majority of this class has now been completed.
 It has been subjected to cursory, informal testing, including a preliminary
 linkup with Rob's queue class.
\layout Standard

It was decided to break each animation primitive into even simpler animation
 events (e.g.
 moving an element out of its slot to lie beside the vector, moving an element
 vertically in this 
\begin_inset Quotes eld
\end_inset 

channel
\begin_inset Quotes erd
\end_inset 

, etc) which would then be queued internally by the animator and executed
 sequentially.
 This makes the system extensible, as there is a single global 
\family typewriter 
Timer
\family default 
 which sends periodic 
\family typewriter 
ActionEvent
\family default 
s to the animator to tell it to draw the next frame, at which point a central
 method (
\family typewriter 
actionPerformed()
\family default 
) looks at the current animation event (represented by an instance of the
 
\family typewriter 
AnimationEvent
\family default 
 inner class) to see what should be done next.
 It is a slightly complicated design, especially given that 
\family typewriter 
wait
\family default 
s and 
\family typewriter 
notify
\family default 
s have been added to prevent animation primitive methods from exiting until
 the relevant animation has been completed (for the sake of Rob's queue).
 However, it works and is still fairly easy to understand, and this, coupled
 with its extensibility, mean that we will not be changing this fundamental
 design.
\layout Standard

The following features have yet to be implemented:
\layout Itemize

Moving elements between separate vectors
\layout Itemize

Highlighting of vector columns (for Radix sort)
\layout Standard

There are also likely to be a few more small changes to the API (for instance
 adding back in support for a boolean method 
\family typewriter 
highlight()
\family default 
 on vectors and arrows to indicate a temporary change of colour) and these
 facilities also have yet to be coded, although the implementation is likely
 to be fairly simple.
 There 
\emph on 
may
\emph default 
 also be an addition which allows the algorithm designer to specify whether
 an arrow is to be placed on the left or right of a vector: again, the implement
ation of this will not be difficult, because at present there is a boolean
 field in each 
\family typewriter 
Arrow
\family default 
 object which determines this property (at the moment, it is always set
 to 
\family typewriter 
false
\family default 
, so that all all arrows appear on the right of their vectors): all that
 is required is to allow the user to set this at the time of arrow creation.
 (It will not be possible to alter this property after creation time.) A
 facility to alter the colour of an arrow may also be provided (at the moment
 they are all blue).
\layout Standard

A problem has also been discovered with saving and restoring the animator
 state, when this is done by the queue in order to roll back to a previous
 algorithm step (checkpoint).
 The problem occurs when a new vector has been created since the last checkpoint.
 If the queue then attempts to restore the animator to the state before
 the vector was created, and run the algorithm again from that point, the
 
\family typewriter 
createVector()
\family default 
 method will be called again to create the same vector.
 This would not be a problem, were it not for the fact that the animator
 decides where to place new vectors on the basis of an integer field, 
\family typewriter 
highestColUsed
\family default 
, which tracks how many vectors there currently are on the canvas.
 The animator places the new vector to the right of what it thinks is the
 right-most vector: unfortunately, if the state is rolled back, this variable
 is not restored to its value at the time of the checkpoint, so the new
 vector is drawn to the right of its previous position and the whole restore
 mechanism breaks.
\layout Standard

This will be remedied by using a more advanced way of laying out vectors
 on screen, which will keep track of which columns are vacant and insert
 newly-created vectors into the left-most free column.
 This will also solve a problem related to the deletion of vectors and arrows:
 at present, the space occupied by a deleted vector will be permanently
 left blank, and cannot be filled by another vector.
\layout Standard

Finally, there is a more fundamental problem with this class in that it
 is not easy to change the format or layout of the canvas.
 For example, it would be difficult to change the width of vectors, or the
 size of the text, or the height of elements, or the gap between vectors,
 without altering myriad numbers within the class.
 If time permits, the code should be tidied up to put basic dimensions in
 global variables, to make them easier to change.
\layout Standard

More testing needs to be done on this class: all animation primitives need
 to be exhaustively tested, especially the ones involving moving arrows
 very close together (it is unclear whether they will be redrawn correctly).
 Input of extreme data (e.g.
 very long vectors, large vector elements, or long arrow labels) is also
 a concern.
 The person responsible for the testing of this class is Alan.
\layout Subsection

Queues (Rob)
\layout Standard

Functionally complete.
 Untested.
\layout Subsection

Shell
\layout Standard

The user interface which will be implemented by the shell has been designed,
 and a proof of concept created.
 This has yet to be written though.
\layout Standard

There will be three main screens in the system:
\layout Enumerate


\emph on 
The algorithm selection screen
\emph default 
 (Diagram 1): this will be the screen that appears first when the system
 is loaded.
 It will have a list of available algorithms, with a description of each
 algorithm showing when the algorithm is selected.
 There will be a 'Next' button which when clicked will advance to the data
 input screen.
 
\layout Enumerate


\emph on 
The data input screen
\emph default 
 (Diagram 2): this will have some text boxes for user input, the number
 of boxes will depend on the algorithm used.
 It will have a 'Random' button to generate random input, a 'Back' button
 to return to the algorithm select menu, and two buttons to start the algorithm.
 The 'Run Automatically' button will start the algorithm and run it through
 to completion, the 'Run Manually' button will animate the algorithm one
 step at a time, with the user choosing when to move on.
\layout Enumerate

The animation screen (Diagram 3): This will show the animation of the algorithm,
 along with a description of what is happening at each step.
 There will be 'Next' and 'Previous' buttons to step through the algorithm,
 as well as a 'Restart' button to return to the first step, and an 'Exit'
 button to return to the algorithm select screen.
\layout Section

Test results
\layout Standard

Say what we are testing it for and how we are testing it
\layout Section

Documentation
\layout Standard

The user guide has been written by Graham, but will be updated in more detail
 as the project takes shape.
 The developers guide for adding new algorithms to the system has been written
 by Neofytos, again this will be updated in more detail as the project progresse
s.
 Current copies of both have been submitted.
\layout Section

Plan of attack
\layout Standard

Badgers
\newline 

\newline 

\the_end
