#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize a4paper
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

Animating Algorithms: Project Specification
\layout Author

Steven Cooper (
\family typewriter 
sjc209
\family default 
), Graham Le Page (
\family typewriter 
gpl26
\family default 
), Zhan Li (
\family typewriter 
zrll2
\family default 
), 
\newline 
Robert McQueen (
\family typewriter 
ram48
\family default 
), Andrew Medworth (
\family typewriter 
am502
\family default 
), 
\newline 
Neofytos Mylona (
\family typewriter 
nm314
\family default 
), Sidath Senanayake (
\family typewriter 
sas58
\family default 
), 
\newline 
Alan Treanor (
\family typewriter 
ajit2
\family default 
)
\layout Section

Introduction
\layout Standard

This is the specification document for the 
\begin_inset Quotes eld
\end_inset 

Animating Algorithms
\begin_inset Quotes erd
\end_inset 

 (Topic 8.5) Computer Science Tripos Part IB / Part II (General) group project.
 The authors are the members of group 
\begin_inset Quotes eld
\end_inset 

Alpha
\begin_inset Quotes erd
\end_inset 

, listed individually above.
\layout Section

Background
\layout Standard

The field of algorithms and data structures is one of the hardest parts
 of Computer Science to teach.
 When done on blackboards or overhead projectors, diagrams can get extremely
 messy and hard to follow; even when the steps of an algorithm are clearly
 displayed on paper, it is not always immediately clear what operations
 have been done between each step.
\layout Standard

Computer animation would be an ideal way to demonstrate algorithms: the
 actions taken by the computer at each stage can be clearly demonstrated
 at whatever level of abstraction is most helpful.
 Users could move through an algorithm's execution at their own speed, going
 especially slowly over difficult steps.
 Critical information can be shown in a clear, intuitive way using colour
 coding, and this can be reinforced with clean, smooth graphical animations
 which show exactly what is going on internally as the algorithm is executed.
 The cost of the algorithm in time and space on different sizes of input
 could also be clearly displayed.
\layout Standard

Clearly, a system to animate any conceivable algorithm working on any imaginable
 data structure is well beyond the scope of a six-week project, but we believe
 it should be possible to provide an extensible system with animation primitives
 enabling the illustration of algorithms which operate on vectors and lists
 (for example sorting, searching and heap algorithms) or graphs (for example
 shortest-path and strongly-connected component finding algorithms) within
 the available time.
\layout Section

Assumptions
\layout Itemize

The 
\begin_inset Quotes eld
\end_inset 

animation script
\begin_inset Quotes erd
\end_inset 

 and the algorithms themselves will be written in Java; we will not implement
 our own special language for describing algorithms.
 
\layout Itemize

The user will be able to specify initial data in the following ways:
\begin_deeper 
\layout Itemize

For 
\emph on 
vectors
\emph default 
: the size of the initial array (up to a maximum of 20 elements), and the
 initial contents of each cell (which must be 
\family typewriter 
int
\family default 
s: there is no need to demonstrate algorithms on multiple data types).
 There will be no option to invert the ordering, as this will not aid understand
ing of the algorithm.
\layout Itemize

For 
\emph on 
graphs
\emph default 
: the ability to specify the number of nodes (up to a maximum of 10), and
 input the elements of the connectivity matrix (which must all be integers).
\end_deeper 
\layout Itemize

The user will set the input data once, before the animation starts, and
 after that time he/she will not be able to alter the data without starting
 again.
\layout Itemize

The auxiliary displays showing the time and space costs of the algorithm,
 and the steps and explanation of its behaviour, will be implemented with
 a series of textual messages displayed to the user as the algorithm is
 animated.
\layout Section

Facilities to Be Provided
\layout Standard

The following facilities will definitely be provided:
\layout Itemize

Support for algorithms on vectors, lists and graphs
\layout Itemize

Neat, non-flickering graphical animation
\layout Itemize

Ability to step through algorithms, both forwards and backwards, at user's
 speed
\layout Itemize

Ability to specify initial data / input (plus ability to generate random
 initial data and special cases such as all entries in a vector being the
 same)
\layout Itemize

Ability to add new algorithms using existing animation primitives
\layout Itemize

Well-documented API for creation of new animation primitives and data structures
, potentially allowing the implementation of different types of algorithm
 from the ones done here
\layout Itemize

Cross-platform operation using Java
\layout Itemize

Easy-to-use, user-friendly interface 
\layout Itemize

We will be demonstrating the system by implementing the following algorithms:
 insertion sort, Quicksort, radix sort, Dijkstra's algorithm (for finding
 the shortest path between two nodes in a graph), and Kruskal's algorithm
 (for finding the minimum spanning tree of a set of nodes in a graph).
\layout Standard

The following facilities will be optionally implemented subject to time
 constraints:
\layout Itemize

Ability to vary animation speed (between two reasonable values)
\layout Itemize

Text explanation of each step as it happens (pseudocode as in a debugger)
\layout Itemize

Display of the time and space costs of the algorithm (in text or graphical
 mode)
\layout Itemize

A graph editor which allows the user to place the nodes on the animation
 canvas, and to specify the edges connecting the nodes using mouse clicks
\layout Itemize

Support for bipartite graphs
\layout Itemize

More algorithms, e.g.
 Prim's algorithm, shell sort, strongly connected component finding algorithm
\layout Section

Environment
\layout Standard

Based on our current knowledge and the availability of development tools,
 we have decided that:
\layout Itemize

The system will be written using the Java 2 SDK on the Eclipse IDE, a powerful,
 free, open-source Java development environment;
\layout Itemize

The GUI will be implemented in the Swing windowing toolkit;
\layout Itemize

Program testing will be done using JUnit, integrated into the Eclipse platform
 as a plugin;
\layout Itemize

Version control will be provided by 
\family typewriter 
cvs
\family default 
.
\layout Section

Overall System Architecture
\layout Standard

The main functionality of the system can be broken down into four areas:
\layout Itemize

Algorithms: (can anyone put just a line of explanation here for each of
 these areas?)
\layout Itemize

Animators
\layout Itemize

Queues
\layout Itemize

Shell
\layout Standard

which will be represented as packages in Java.
 The following sections contain a brief description of each package, the
 classes within, and their interactions.
\layout Subsection

Algorithms
\layout Standard

The classes within this package will ultimately implement the algorithms
 which the system is able to demonstrate, contain the instructions to the
 other parts of the program for animating the steps that are taken by the
 algorithm, provide the narrative for explaining to the user what is happening,
 and any other information which is displayed.
\layout Standard

The abstract class Algorithm is the parent class for all of the classes
 within this package, and an abstract class is descended from it for each
 group of algorithms which are being implemented.
 The initial specification is to implement two types of algorithm, GraphAlgorith
m and SortAlgorithm.
 These abstract classes will contain methods for querying information about
 the algorithm, such as its name and purpose, explanation of steps, efficiency,
 as well as setting the initial data for the algorithm and instructing it
 to execute.
\layout Subsection

Animators
\layout Standard

This package contains a set of abstract classes descended from Animator
 which have methods and inner classes to specify the animation primitives
 necessary for each group of algorithms.
 There will initially be two classes descended from Animator, GraphAnimator
 and SortAnimator, which will specify the methods necessary for the following
 primitives.
\layout Subsubsection

Graph Animator Primitives
\layout Paragraph

Node
\layout Itemize

Create node (with label)
\layout Itemize

Delete node
\layout Itemize

Change node label
\layout Itemize

Highlight node (to indicate current focus of algorithm)
\layout Itemize

Shade node (to indicate membership of a set of nodes or paths)
\layout Paragraph

Path (joins two nodes)
\layout Itemize

Create path (with cost, label and origin/destination nodes)
\layout Itemize

Delete path
\layout Itemize

Change path label
\layout Itemize

Highlight path (to indicate current focus of algorithm)
\layout Itemize

Shade path (to indicate membership of a set of nodes or paths)
\layout Subsubsection

Sort Animator Primitives
\layout Paragraph

Vector (array of numbers)
\layout Itemize

Create vector (with data and label)
\layout Itemize

Delete vector
\layout Itemize

Change vector label
\layout Itemize

Swap elements at two pointers
\layout Itemize

Split vector into two at a marker (for Quicksort)
\layout Paragraph

Marker (points at a boundary between two entries in the vector)
\layout Itemize

Create marker (with label and position)
\layout Itemize

Delete marker
\layout Itemize

Change marker label
\layout Itemize

Move marker
\layout Itemize

Highlight marker (to indicate current focus of algorithm)
\layout Paragraph

Pointer (points at a specific entry in the vector)
\layout Itemize

Create pointer (with label and position)
\layout Itemize

Delete pointer
\layout Itemize

Change pointer label
\layout Itemize

Move pointer
\layout Itemize

Highlight pointer (to indicate current focus of algorithm)
\layout Subsection

Queues
\layout Standard

This package contains an interface AnimatorQueue, and two classes which
 impl
\layout Subsection

Shell
\layout Standard

What the major components (classes) are and how they will fit together (to
 include UML Use Case diagram, UML Class diagram, and all the usual gimmicks).
\layout Standard

show diagram, explain diagram in detail, explain why diagram is the way
 it is
\layout Section

Overall Inputs, Functions, and Outputs
\layout Standard

User inputs:
\layout Itemize

Algorithm selection (from the ones implemented)
\layout Itemize

Initial data (keyboard input for vector elements, graph edge costs) including
 ability to generate random data and special cases with mouse clicks
\layout Itemize

Navigation through algorithm with mouse clicks
\layout Itemize

Animation speed (using mouse) 
\emph on 
[optional]
\layout Itemize

Graph node locations and other layout information (using mouse, in graph
 editor) 
\emph on 
[optional]
\layout Standard

Functions:
\layout Itemize

Simulate algorithm using given initial data, storing the state at each stage
 to facilitate forward and backward movement, plus information displays
 such as time and space cost
\layout Itemize

Animate each step in the algorithm when the user moves forward
\layout Standard

Outputs:
\layout Itemize

Animation displayed on screen
\layout Itemize

Time and space cost display 
\emph on 
[optional]
\layout Itemize

Pseudocode 
\emph on 
[optional]
\layout Section

Specification of Components and Test Requirements
\layout Standard

For each major class in the system:
\layout Itemize

Its purpose, including what functionality is it supposed to provide to the
 user or to other classes
\layout Itemize

Its inputs
\layout Itemize

Its outputs
\layout Itemize

Its major public methods (replicating some of the stuff in the abstract
 class listings)
\layout Itemize

How it should be tested
\layout Subsection

User interface / shell
\layout Subsection

Actual animator
\layout Subsection

Animation queuer thingy
\layout Standard

We will be implementing the following animation primitives for vectors:
\layout Itemize

Create new vector
\layout Itemize

Yadda
\layout Standard

We will be implementing the following animation primitives for graphs:
\layout Itemize

Yodda
\layout Itemize

Yudda
\layout Standard

Test requirements: (move these to appropriate classes)
\layout Itemize

make sure algorithms work correctly and produce the right result in all
 circumstances, even when dealing with extreme data eg.
 all 0's
\layout Itemize

make sure valid inputs are dealt with sensibly
\layout Itemize

make sure invalid (i.e.
 non-integers in vectors) inputs are dealt with sensibly
\layout Itemize

make sure the display shows the correct information at each step
\layout Itemize

make sure the next/back buttons work, eg.
 what happens if they are pressed during animations
\layout Itemize

make sure the graphical user interface works correctly
\layout Subsection

The algorithms themselves
\layout Section

Final Acceptance Criteria
\layout Itemize

The system must provide a responsive, user-friendly and crash-prone interface;
\layout Itemize

(We need more here.)
\layout Section

Division of tasks
\layout Standard

The division of tasks is described in Table 
\begin_inset LatexCommand \ref{table:division-of-tasks}

\end_inset 

.
 Group members with 
\emph on 
(backup)
\emph default 
 written next to their names will be called upon to perform that task in
 the event that the others cannot complete it on their own, or extra effort
 is needed.
\layout Standard


\begin_inset Float table
placement bp
wide false
collapsed false

\layout Caption


\begin_inset LatexCommand \label{table:division-of-tasks}

\end_inset 

Division of project tasks
\layout Standard
\align center 

\begin_inset  Tabular
<lyxtabular version="3" rows="6" columns="2">
<features>
<column alignment="right" valignment="top" leftline="true" width="0(null)">
<column alignment="block" valignment="top" leftline="true" rightline="true" width="3in">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Manager
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Graham Le Page
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Librarian
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Robert McQueen
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Secretary
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Andrew Medworth
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
User documentation
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Neofytos Mylona
\layout Standard

Graham Le Page
\layout Standard

Alan Treanor
\layout Standard

Andrew Medworth 
\emph on 
(backup)
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Design & Coding
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Robert McQueen
\layout Standard

Steven Cooper
\layout Standard

Andrew Medworth
\layout Standard

Sidath Senanayake
\layout Standard

Zhan Li 
\emph on 
(backup)
\end_inset 
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\layout Standard


\family sans 
\series bold 
Troubleshooting & Testing
\end_inset 
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\layout Standard

Zhan Li
\layout Standard

Alan Treanor
\layout Standard

Sidath Senanayake 
\emph on 
(backup)
\layout Standard


\emph on 
As many others as are required
\end_inset 
</cell>
</row>
</lyxtabular>

\end_inset 


\end_inset 


\the_end
